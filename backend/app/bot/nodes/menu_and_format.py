"""Bot nodes â€” menu_retrieval + response_formatter"""
import uuid
from app.bot.state import BotState
from app.database import AsyncSessionLocal
from app.models.menu import MenuCategory, MenuItem
from sqlalchemy import select


VEG_EMOJI = {"veg": "ğŸŸ¢", "nonveg": "ğŸ”´", "jain": "ğŸŒ¿"}
SPICE_EMOJI = {"mild": "ğŸŒ¶", "medium": "ğŸŒ¶ğŸŒ¶", "hot": "ğŸŒ¶ğŸŒ¶ğŸŒ¶"}


async def menu_retrieval(state: BotState) -> BotState:
    """Fetch menu categories or items and prepare response payload."""
    branch_id = state.get("branch_id")
    entities = state.get("entities", {})
    item_name_hint = (entities.get("item_name") or "").lower()

    if not branch_id:
        state["error"] = "no_branch_id"
        return state

    async with AsyncSessionLocal() as db:
        # 1. Show items for a specific category
        cat_id = entities.get("category_id")
        if cat_id:
            try:
                items_result = await db.execute(
                    select(MenuItem).where(
                        MenuItem.category_id == uuid.UUID(cat_id),
                        MenuItem.is_available == True
                    )
                )
                items = items_result.scalars().all()
                if not items:
                    state["final_response"] = {"type": "text", "body": "No items found in this category. ğŸ“‹"}
                    return state

                rows = []
                for item in items[:10]:
                    veg = VEG_EMOJI["veg"] if item.is_veg else VEG_EMOJI["nonveg"]
                    # WhatsApp limit for title is 24 chars. Veg emoji + space is ~2-3 chars.
                    title = f"{veg} {item.name}"[:24]
                    rows.append({
                        "id": f"item_{item.id}",
                        "title": title,
                        "description": f"â‚¹{item.base_price:.0f}",
                    })
                state["final_response"] = {
                    "type": "list",
                    "body": "Select an item to add to your cart: ğŸ‘‡",
                    "button_label": "View Items",
                    "sections": [{"title": "Category Items", "rows": rows}],
                }
                return state
            except (ValueError, Exception) as e:
                print(f"Error fetching category items: {e}")

        # 2. Veg / Non-Veg search filter
        is_veg_filter = entities.get("is_veg")
        if is_veg_filter is not None:
            items_result = await db.execute(
                select(MenuItem).where(
                    MenuItem.branch_id == uuid.UUID(branch_id),
                    MenuItem.is_veg == is_veg_filter,
                    MenuItem.is_available == True
                )
            )
            items = items_result.scalars().all()
            if not items:
                state["final_response"] = {"type": "text", "body": f"Sorry, couldn't find any {'veg' if is_veg_filter else 'non-veg'} items content. ğŸ“‹"}
                return state

            rows = []
            for item in items[:10]:
                veg = VEG_EMOJI["veg"] if item.is_veg else VEG_EMOJI["nonveg"]
                title = f"{veg} {item.name}"[:24]
                rows.append({"id": f"item_{item.id}", "title": title, "description": f"â‚¹{item.base_price:.0f}"})
            
            state["final_response"] = {
                "type": "list",
                "body": f"Here are our {'Veg' if is_veg_filter else 'Non-Veg'} items: ğŸ‘‡",
                "button_label": "View Items",
                "sections": [{"title": "Filter Results", "rows": rows}],
            }
            return state

        # 3. Fuzzy search for item hint
        if item_name_hint:
            items_result = await db.execute(
                select(MenuItem).where(
                    MenuItem.branch_id == uuid.UUID(branch_id),
                    MenuItem.is_available == True,
                )
            )
            all_items = items_result.scalars().all()
            matched = [i for i in all_items if item_name_hint in i.name.lower()]
            if not matched:
                matched = all_items[:10]  # fallback: show first 10

            if not matched:
                state["final_response"] = {"type": "text", "body": "Sorry, no items are available at the moment. ğŸ“‹"}
                return state

            rows = []
            for item in matched[:10]:
                veg = VEG_EMOJI["veg"] if item.is_veg else VEG_EMOJI["nonveg"]
                spice = SPICE_EMOJI.get(item.spice_level, "") if item.spice_level else ""
                title = f"{veg} {item.name}"[:24]
                rows.append({
                    "id": f"item_{item.id}",
                    "title": title,
                    "description": f"â‚¹{item.base_price:.0f} {spice}",
                })
            state["final_response"] = {
                "type": "list",
                "body": "Here are the matching items ğŸ‘‡\nTap one to add it to cart:",
                "button_label": "View Items",
                "sections": [{"title": "Menu Items", "rows": rows}],
            }
        else:
            # 4. Default: Show categories
            cats_result = await db.execute(
                select(MenuCategory).where(
                    MenuCategory.branch_id == uuid.UUID(branch_id),
                    MenuCategory.is_active == True,
                ).order_by(MenuCategory.sort_order)
            )
            cats = cats_result.scalars().all()
            if not cats:
                state["final_response"] = {"type": "text", "body": "The menu is currently being updated. Please check back in a few minutes! ğŸ“‹"}
                return state

            rows = [{"id": f"cat_{c.id}", "title": c.name[:24], "description": f"~{c.estimated_prep_minutes} min" if c.estimated_prep_minutes else ""} for c in cats[:10]]
            state["final_response"] = {
                "type": "list",
                "body": "ğŸ“‹ Our Menu Categories â€” tap to browse:",
                "button_label": "Browse Menu",
                "sections": [{"title": "Categories", "rows": rows}],
            }
    return state


async def item_info_node(state: BotState) -> BotState:
    """Show item details and ask for quantity using buttons."""
    entities = state.get("entities", {})
    item_id = entities.get("item_id")
    
    if not item_id:
        state["final_response"] = {"type": "text", "body": "Which item? Please select from the menu. ğŸ“‹"}
        return state

    async with AsyncSessionLocal() as db:
        res = await db.execute(select(MenuItem).where(MenuItem.id == uuid.UUID(item_id)))
        item = res.scalar_one_or_none()
        
        if not item:
            state["final_response"] = {"type": "text", "body": "Item not found. ğŸ“‹"}
            return state

        veg = VEG_EMOJI["veg"] if item.is_veg else VEG_EMOJI["nonveg"]
        body = (
            f"*{veg} {item.name}*\n"
            f"ğŸ’° Price: â‚¹{item.base_price:.0f}\n\n"
            "How many portions would you like? ğŸ‘‡"
        )
        
        state["final_response"] = {
            "type": "buttons",
            "body": body,
            "buttons": [
                {"id": f"qty_1_{item.id}", "title": "1 Portion"},
                {"id": f"qty_2_{item.id}", "title": "2 Portions"},
                {"id": f"qty_5_{item.id}", "title": "5 Portions"},
            ]
        }
    return state


async def response_formatter(state: BotState) -> BotState:
    """Build WA-sendable payload from state.final_response."""
    # final_response is already set by other nodes; this node is a pass-through
    # to allow future enrichment (language, personalisation, etc.)
    lang = state.get("preferred_language", "en")

    if not state.get("final_response"):
        if state.get("error") == "no_session":
            state["final_response"] = {
                "type": "text",
                "body": "ğŸ‘‹ Please scan the QR code on your table to start ordering.",
            }
        elif state.get("error") == "invalid_token":
            state["final_response"] = {
                "type": "text",
                "body": "âŒ Invalid or expired QR code. Please ask staff for a new one.",
            }
        else:
            state["final_response"] = {
                "type": "text",
                "body": "I didn't understand that. Try: *show menu*, *add [item]*, *confirm*, or *bill please*.",
            }
    return state
